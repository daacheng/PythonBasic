### 1.UDP和TCP的特点和区别
#### UDP：User Datagram Protocol,用户数据报协议
* 面向无连接
* 尽最大努力交付，不可靠传输，没有流量控制和拥塞控制
* 支持一对一，一对多和多对一通信
* 面向报文（对于应用层传下来的报文直接打包）
* 首部开销小，只有8字节

#### TCP：Transmission Control Protocol，传输控制协议
* 面向连接
* 提供可靠传输，有流量控制和拥塞控制
* 只能是一对一通信
* 面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）
* 首部开销大，最小20字节，最大60字节

### 2.UDP和TCP的首部
**UDP的首部只有8个字节，源端口号，目的端口号，长度，校验和**

**TCP的首部比较复杂，[TCP首部](TCP首部.md)**

### 3.TCP的三次握手与四次挥手过程，为什么是三报文建立连接，为什么是四报文释放连接
[TCP连接的建立与释放](TCP连接的建立与释放.md)

### 4.TCP短连接和长连接的区别
#### 短连接
Client向Server发送消息，Server回应Client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是 Client先发起close操作。短连接一般只会在Client/Server间传递一次读写操作。

短连接管理起来比较简单，建立存在的连接都是有用的连接，不需要额外的控制手段。

#### 长连接
Client与Server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。

在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server端的压力会越来越大，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免客户端连累后端服务。

### 5.TCP的粘包，拆包
#### UDP没有粘包问题
TCP是基于字节流的传输，虽然应用层和传输层之间数据交互是大小不同的数据块，但是TCP并没有对这些数据块区分边界，仅仅是一连串没有结构的字节流；UDP是基于报文传输的，有区分边界，不会发生粘包情况
#### 为什么会发生粘包拆包
TCP是基于字节流传输的，在传输过程中，对于应用层的一个数据包，在传输层可能会拆分成多个字节数据块传输（拆包），也可能是多个数据包合并成一个字节数据块传输（粘包）
* 要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包
* 待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包
* 要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包
* 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包

#### 解决办法
在传输层无法保证数据包不被拆分和合并，只能通过应用层制定相关的协议，在应用层接收数据的时候根据协议解决粘包和拆包的问题，比如应用层协议规定消息头标识（边界），定义消息头与消息体，定义数据长度等。应用层在接收数据的时候根据头标识接收指定长度的消息头，然后解析获取消息长度，再接收指定长度的消息体，这样就能解决粘包和拆包的问题了

### 6.TCP的流量控制
[TCP的流量控制](TCP的流量控制.md)
### 7.TCP的拥塞控制
[TCP的拥塞控制](TCP的拥塞控制.md)
### 8.TCP的可靠传输实现
[TCP可靠传输的实现](TCP可靠传输的实现.md)
